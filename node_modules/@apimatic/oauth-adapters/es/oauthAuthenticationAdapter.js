import { __awaiter, __generator } from 'tslib';
import { passThroughInterceptor } from '@apimatic/core-interfaces';
import { setHeader, AUTHORIZATION_HEADER } from '@apimatic/http-headers';
var requestAuthenticationProvider = function (initialOAuthToken, oAuthTokenProvider, oAuthOnTokenUpdate, oAuthConfiguration) {
  // This token is shared between all API calls for a client instance.
  var lastOAuthToken = Promise.resolve(initialOAuthToken);
  return function (requiresAuth) {
    if (!requiresAuth) {
      return passThroughInterceptor;
    }
    return function (request, options, next) {
      return __awaiter(void 0, void 0, void 0, function () {
        var oAuthToken;
        return __generator(this, function (_a) {
          switch (_a.label) {
            case 0:
              return [4 /*yield*/, lastOAuthToken];
            case 1:
              oAuthToken = _a.sent();
              if (!(oAuthTokenProvider && (!isValid(oAuthToken) || isExpired(oAuthToken, oAuthConfiguration === null || oAuthConfiguration === void 0 ? void 0 : oAuthConfiguration.clockSkew)))) return [3 /*break*/, 3];
              // Set the shared token for the next API calls to use.
              lastOAuthToken = oAuthTokenProvider(oAuthToken);
              return [4 /*yield*/, lastOAuthToken];
            case 2:
              oAuthToken = _a.sent();
              if (oAuthOnTokenUpdate && oAuthToken) {
                oAuthOnTokenUpdate(oAuthToken);
              }
              _a.label = 3;
            case 3:
              setOAuthTokenInRequest(oAuthToken, request, oAuthConfiguration === null || oAuthConfiguration === void 0 ? void 0 : oAuthConfiguration.clockSkew);
              return [2 /*return*/, next(request, options)];
          }
        });
      });
    };
  };
};
function setOAuthTokenInRequest(oAuthToken, request, clockSkew) {
  var _a;
  validateAuthorization(oAuthToken, clockSkew);
  request.headers = (_a = request.headers) !== null && _a !== void 0 ? _a : {};
  setHeader(request.headers, AUTHORIZATION_HEADER, "Bearer " + (oAuthToken === null || oAuthToken === void 0 ? void 0 : oAuthToken.accessToken));
}
function validateAuthorization(oAuthToken, clockSkew) {
  if (!isValid(oAuthToken)) {
    throw new Error('Client is not authorized. An OAuth token is needed to make API calls.');
  }
  if (isExpired(oAuthToken, clockSkew)) {
    throw new Error('OAuth token is expired. A valid token is needed to make API calls.');
  }
}
function isValid(oAuthToken) {
  return typeof oAuthToken !== 'undefined';
}
function isExpired(oAuthToken, clockSkew) {
  if (typeof oAuthToken.expiry === 'undefined') {
    return false; // Expiry is undefined, token cannot be expired
  }

  var tokenExpiry = oAuthToken.expiry;
  // Adjust expiration time if clockSkew is provided and is not undefined
  if (clockSkew && typeof clockSkew !== 'undefined') {
    tokenExpiry -= BigInt(clockSkew); // Subtract clockSkew from expiry
  }

  return tokenExpiry < Date.now() / 1000;
}
export { isExpired, isValid, requestAuthenticationProvider };